{"posts":[{"title":"Profile","text":"PhD Student in Compilers Institute for Computing Systems ArchitectureSchool of InformaticsThe University of Edinburgh3.48 Informatics Forum10 Crichton St,Edinburgh, ScotlandEH8 9AB Email: ds1231h@gmail.comGitHub: https://github.com/PeiMu Pei Mu, a PhD student, supervised by Antonio Barbalace and Amir Shaikhha, with the Institute for Computing Systems Architecture (ICSA) in the School of Informatics at The University of Edinburgh. My research interests are deep learning compilers (e.g. MLIR, TVM) and traditional compilers (e.g. LLVM). Education 2022-now PhD (Compiler Optimization) - Informatics, the University of Edinburgh 2014-2018 BSc Hons in Engineering - Shandong University Industry Experiences Microsoft Research Lab – Asia Internship in the system group - Deep Learning Compilers SenseTime Researcher in Research Institute - Deep Learning Compiler Group Huawei Technologies Co., Ltd Algorithm Engineer in 2012 Lab - Compiler and Programming Language Lab Publication Machine Learning Systems: Design and Implementation, Chapter 7, Compiler Backend and Runtime Zhang L (Corresponding author), Mu P, Kim JW. Implement of extended shortcut tree routing for ZigBee-based car park wireless sensor management system. In2017 4th International Conference on Systems and Informatics (ICSAI) 2017 Nov 11 (pp. 890-894). IEEE. Zhang L (Corresponding author), Liu X, Mu P, Kim JW. Design of Intelligent Diagnosis System for Heavyweight Measurement System Based on IOT. In2016 International Conference on Electrical, Mechanical and Industrial Engineering 2016 Apr (pp. 285-288). Atlantis Press. Awards Huawei technology breakthrough award, 2020 Huawei technology breakthrough award, 2019 ICM/MCM - honorable mention, 2017 ICM/MCM - honorable mention, 2016 CUMCM - First prize of Shandong Province, 2016 CUMCM - Third prize of Shandong Province, 2015 Patent Title of invention: Method, device and electronic equipment for optimizing vectorization in compilation process - Public number (public) CN112947932A","link":"/2023/11/14/profile/"},{"title":"LLVM IR Instructions&#39; trick","text":"LLVM IR instructions are the basic elements while we are writing LLVM PASS codes. Here are some interesting experiences. A basic classification of the commonly used LLVM IR instructionsHere is a brief classification of the instructions based on the operand numbers. This classification would be useful when you want to analyze the operands and result op of instructions.The type in different positions in the instruction usually needs to be guaranteed to be the same (be more careful especially when you need to change the type of an instruction). Alloca Instruction1%i = alloca type The type of this instruction is `type*. Call InstructionThere are two different kinds of call instruction in LLVM. 1%i = call retType @func_name (type %p1, ...) and 1call void @llvm.dbg.declare/value (metadata type %p, ...) The second one is quite interesting and will be explained in the next section. Load Instruction1%i = load type, type* %op The type of this instruction is type, but not type*. Store Instruction1store type %op1, type* %op2 GetElementPtr Instruction1%i = gep type, type1* %op1, type2 %op2, (type3 %op3) Binary Instruction1%i = binaryInst type %op1, %op2 binaryInst here is a representative word, it can be Add, FAdd, etc. Unary Instruction1%i = unaryInst type %op Same as the binaryInst in the Binary Instruction section, unaryInst in the above code is a representative word, which can be FNeg, etc. Cast Instruction1%i = castInst type1 %op1 to type2 Same as the binaryInst in the Binary Instruction section, castInst in the above code is a representative word, it actually can be FPToUI, FPToSI, SIToFP, UIToFP, ZExt, SExt, FPExt, Trunc, FPTrunc, BitCast. PHI Instruction1%.i = phi type [%op1, %bb1], [%op2, %bb2], ... Get debug information from Instruction::CallFor the LLVM-define call instruction, like llvm.dbg.value and llvm.dbg.declare, we can easily get almost every debug information (as long as you compile with debug config, -O0 -g) from the LLVM metadata.Here’s a piece of code about how to get the debug information you want from IR. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849case Instruction::Call: if (auto llvmIrCallInstruction = dyn_cast&lt;CallInst&gt;(&amp;llvmIrInstruction)) { Function * calledFunction = llvmIrCallInstruction-&gt;getCalledFunction(); if (calledFunction == nullptr || !calledFunction-&gt;hasName() || calledFunction-&gt;getName().empty()) break; if (calledFunction-&gt;getName().startswith(&quot;llvm.dbg.value&quot;) || calledFunction-&gt;getName().startswith(&quot;llvm.dbg.declare&quot;)) { if (!isa&lt;MetadataAsValue&gt;(llvmIrCallInstruction-&gt;getOperand(0))) break; auto firstOperator = cast&lt;MetadataAsValue&gt;(llvmIrCallInstruction-&gt;getOperand(0)); if (!isa&lt;ValueAsMetadata&gt;(firstOperator-&gt;getMetadata())) break; auto localVariableAddressAsMetadata = cast&lt;ValueAsMetadata&gt;(firstOperator-&gt;getMetadata()); auto localVariableAddress = localVariableAddressAsMetadata-&gt;getValue(); auto variableMetadata = cast&lt;MetadataAsValue&gt;(llvmIrCallInstruction-&gt;getOperand(1)); if (!isa&lt;DIVariable&gt;(variableMetadata-&gt;getMetadata())) break; auto debugInfoVariable = cast&lt;DIVariable&gt;(variableMetadata-&gt;getMetadata()); const DIType * variableType = debugInfoVariable-&gt;getType(); if (const auto * compositeVariableType = dyn_cast&lt;DICompositeType&gt;(variableType)) { /* * It's a composite type, including structure, union, array, and enumeration * Extract from composite type * */ auto typeTag = compositeVariableType-&gt;getTag(); if (typeTag == dwarf::DW_TAG_union_type) { // do something} else if (typeTag == dwarf::DW_TAG_structure_type) { // do something} else if (typeTag == dwarf::DW_TAG_array_type) { const DIType * ElemType = compositeVariableType-&gt;getBaseType(); // do something with element type} else if (typeTag == dwarf::DW_TAG_enumeration_type) { // do something} }} Instructions that imply sign meaningsLLVM’s type system doesn’t explicitly specify the sign of the operand or instruction but uses different instructions to hint at the sign bit. Suggest the sign symbol by the instruction nameLLVM uses UDiv, URem, and LShr to calculate the unsigned operands and get the positive result. Correspondingly, SDiv, Srem, and AShr are for the signed calculation.Also, some type cast instructions, including FPToUI, UIToFP, and ZExt mean the results of these instructions are unsigned values, FPToSI, SIToFP, and SExt are on the opposite. Sign hint in the ICmp instructionThere are hints like sgt, sge, slt, and sle in ICmp to compare as the signed operands, hints like ugt, uge, ult, and ule are for the unsigned operands. Warning flag in the instructionnsw (No Signed Wrap) and nuw (No Unsigned Wrap) are flags to generate poison value if signed and/or unsigned overflow. Copyright NoticeAnyone is free to use it, and please indicate the reference when using or publishing. Thank you! ReferencesLLVM Language Reference Manual","link":"/2023/04/24/LLVM-IR-Instructions-trick/"},{"title":"Compare and Remove the same (redundant) functions in LLVM","text":"BackgroundIn my last blog, I introduced how to clone functions in LLVM. After a range of specific optimization passes, some cloned functions may not change as a redundant function. This blog shows how to delete these redundant functions. Related WorkI didn’t find related discussion on Google. Maybe no one has the need to clone the functions and delete them like I do. But class MergeFunctions in llvm/lib/Transforms/IPO/MergeFunctions.cpp gives a good example. In this class, it didn’t provide an external API, but we can still learn some techniques from it. LLVM’s doc also introduces this clearly. SolutionThe key point is to use std::set, an STL container with unique key value, to filter the unique functions. This means we need to program our own compare functions for the set data structure. diralik provides 5 ways to design a custom std::set comparator. In this blog, I chose the traditional old way with () operator. I used a FunctionNode class to store the Function in LLVM and its FunctionComparator::FunctionHash. Then I had a FunctionNodeCmp class with a custom () operator, and use the FunctionComparator::FunctionHash and FunctionComparator::compare() to compare if two functions are the same. The last step is to insert each function into the std::set. And remember, CodeCopyright NoticeAnyone is free to use it, and please indicate the reference when using or publishing. Thank you! References","link":"/2023/01/14/Compare-and-Remove-the-same-redundant-functions-in-LLVM/"},{"title":"Clone Function in LLVM","text":"LLVM is a powerful compiler infrastructure, but sometimes compiler engineers need to design their own functions for their own purposes. This Blog will introduce how to clone an existing function in LLVM to the same module. BackgroundIn my current project, CoSense (hope will soon be published and open-sourced), I’m going to clone some functions first and optimize each of these cloned functions with specific algorithms. Then my compiler will eliminate the redundant functions. There’s no existing API to clone functions quickly and conveniently, so I did a bit of research and wrote this blog. Related WorkWhile browsing on Google, there are lots of good experiences. KeksimvsMaximvs[1] asked how to clone function in another module, and gave a good solution to it by CloneFunctionInto. Scott A. Carr[2] shared his experience of how to search and fix this problem, which is really helpful, but didn’t provide a usable source code. And both of them didn’t mention that when a callee function is cloned, the callInst node in the caller function should change the called name. In LLVM’s mailing list, Zhang[3] answered this question with CallInst::setCalledFunction. But the problems still didn’t have a good solution. SolutionIn my solution, I use a std::map&lt;std::string, int&gt; to store the cloned function’s ID with the same base function, as they are separate functions with their own names. And the IDs are used to generate the new name of the cloned functions. Then I create the new function with the new name and set arguments to it. Next, I use CloneFunctionInto to generate the new function’s implementation, set visibility and linkage, and copy metadata from the base function. The last step is to insert the new function into the module (also the base function’s parent node), and changed the call instruction. CodeHere’s the partial but sufficient key code. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849std::map&lt;std::string, int&gt; calleeCounter;/* * collect the inner bound info for each callee function. */ auto llvmIrCallInstruction = dyn_cast&lt;CallInst&gt;(&amp;llvmIrInstruction); Function * calledFunction = llvmIrCallInstruction-&gt;getCalledFunction(); auto calleeCounterIt = calleeCounter.find(calledFunction-&gt;getName().str()); if (calleeCounterIt != calleeCounter.end()) { calleeCounterIt-&gt;second++; } else { calleeCounter.emplace(calledFunction-&gt;getName().str(), 0); } std::string newFuncName = calledFunction-&gt;getName().str() + '_' + std::to_string(calleeCounterIt-&gt;second); /* * rename the llvmIrCallInstruction to the new function name */ ValueToValueMapTy vMap; auto overloadFunc = Function::Create(calledFunction-&gt;getFunctionType(), calledFunction-&gt;getLinkage(), calledFunction-&gt;getAddressSpace(), newFuncName); auto *newFuncArgIt = overloadFunc-&gt;arg_begin(); for (auto &amp;arg : calledFunction-&gt;args()) { auto argName = arg.getName(); newFuncArgIt-&gt;setName(argName); vMap[&amp;arg] = &amp;(*newFuncArgIt++); } SmallVector&lt;ReturnInst*, 8&gt; Returns; CloneFunctionInto(overloadFunc, calledFunction, vMap, CloneFunctionChangeType::LocalChangesOnly, Returns); // Set the linkage and visibility late as CloneFunctionInto has some // implicit requirements. overloadFunc-&gt;setVisibility(GlobalValue::DefaultVisibility); overloadFunc-&gt;setLinkage(GlobalValue::PrivateLinkage); // Copy metadata SmallVector&lt;std::pair&lt;unsigned, MDNode *&gt;, 1&gt; MDs; calledFunction-&gt;getAllMetadata(MDs); for (auto MDIt : MDs) { if (!overloadFunc-&gt;hasMetadata()) { overloadFunc-&gt;addMetadata(MDIt.first, *MDIt.second); } } Module &amp;funcModule = *calledFunction-&gt;getParent(); funcModule.getFunctionList().insert(calledFunction-&gt;getIterator(), overloadFunc); overloadFunc-&gt;setDSOLocal(true); llvmIrCallInstruction-&gt;setCalledFunction(overloadFunc); PS: I used LLVM-13, and the function CloneFunctionInto may change in different LLVM versions. ConclusionSo this is how to clone functions in LLVM. I will introduce how to eliminate the same (redundant) function after cloning. It will also be fun. Copyright NoticeAnyone is free to use it, and please indicate the reference when using or publishing. Thank you! References[1] https://stackoverflow.com/questions/61189720/llvm-clone-function-pass-to-different-module[2] http://scottcarr.github.io/2016/01/24/my-week-in-llvm.html[3] https://lists.llvm.org/pipermail/llvm-dev/2018-March/122114.html","link":"/2023/01/13/Clone-Function-in-LLVM/"}],"tags":[{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"About Me","slug":"About-Me","link":"/tags/About-Me/"}],"categories":[],"pages":[]}