{"posts":[{"title":"Profile","text":"PhD Student in Compilers Institute for Computing Systems ArchitectureSchool of InformaticsThe University of Edinburgh3.48 Informatics Forum10 Crichton St,Edinburgh, ScotlandEH8 9AB Email: ds1231h@gmail.comGitHub: https://github.com/PeiMu Pei Mu, a PhD student with the Institute for Computing Systems Architecture (ICSA) in the School of Informatics at The University of Edinburgh. My research interests are deep learning compilers (MLIR, TVM) and traditional compilers (LLVM). Education 2022-2023 Master by Research (Compiler Optimization) - Informatics, the University of Edinburgh 2014-2018 BSc Hons in Engineering - Shandong University Industry Experiences SenseTime Researcher in Research Institute - Deep Learning Compiler Group Huawei Technologies Co., Ltd Algorithm Engineer in 2012 - Compiler and programming language lab Publication Zhang L (Corresponding author), Mu P, Kim JW. Implement of extended shortcut tree routing for ZigBee-based car park wireless sensor management system. In2017 4th International Conference on Systems and Informatics (ICSAI) 2017 Nov 11 (pp. 890-894). IEEE. Zhang L (Corresponding author), Liu X, Mu P, Kim JW. Design of Intelligent Diagnosis System for Heavyweight Measurement System Based on IOT. In2016 International Conference on Electrical, Mechanical and Industrial Engineering 2016 Apr (pp. 285-288). Atlantis Press. ”Machine Learning Systems: Design and Implementation” Chapter 7, Compiler Backend and Runtime Awards Huawei technology breakthrough award, 2020 Huawei technology breakthrough award, 2019 ICM/MCM - honorable mention, 2017 ICM/MCM - honorable mention, 2016 CUMCM - First prize of Shandong Province, 2016 CUMCM - Third prize of Shandong Province, 2015 PatentTitle of invention: Method, device and electronic equipment for optimizing vectorization in compilation process - Public number (public) CN112947932A","link":"/2022/09/13/profile/"},{"title":"Compare and Remove the same (redundant) functions in LLVM","text":"BackgroundIn my last blog, I introduced how to clone functions in LLVM. After a range of specific optimization passes, some cloned functions may not change as a redundant function. This blog shows how to delete these redundant functions. Related WorkI didn’t find related discussion on Google. Maybe no one has the need to clone the functions and delete them like I do. But class MergeFunctions in llvm/lib/Transforms/IPO/MergeFunctions.cpp gives a good example. In this class, it didn’t provide an external API, but we can still learn some techniques from it. LLVM’s doc also introduces this clearly. SolutionThe key point is to use std::set, an STL container with unique key value, to filter the unique functions. This means we need to program our own compare functions for the set data structure. diralik provides 5 ways to design a custom std::set comparator. In this blog, I chose the traditional old way with () operator. I used a FunctionNode class to store the Function in LLVM and its FunctionComparator::FunctionHash. Then I had a FunctionNodeCmp class with a custom () operator, and use the FunctionComparator::FunctionHash and FunctionComparator::compare() to compare if two functions are the same. The last step is to insert each function into the std::set. And remember, CodeCopyright NoticeAnyone is free to use it, and please indicate the reference when using or publishing. Thank you! References","link":"/2023/01/14/Compare-and-Remove-the-same-redundant-functions-in-LLVM/"},{"title":"Clone Function in LLVM","text":"LLVM is a powerful compiler infrastructure, but sometimes compiler engineers need to design their own functions for their own purposes. This Blog will introduce how to clone an existing function in LLVM to the same module. BackgroundIn my current project, CoSense (hope will soon be published and open-sourced), I’m going to clone some functions first and optimize each of these cloned functions with specific algorithms. Then my compiler will eliminate the redundant functions. There’s no existing API to clone functions quickly and conveniently, so I did a bit of research and wrote this blog. Related WorkWhile browsing on Google, there are lots of good experiences. KeksimvsMaximvs[1] asked how to clone function in another module, and gave a good solution to it by CloneFunctionInto. Scott A. Carr[2] shared his experience of how to search and fix this problem, which is really helpful, but didn’t provide a usable source code. And both of them didn’t mention that when a callee function is cloned, the callInst node in the caller function should change the called name. In LLVM’s mailing list, Zhang[3] answered this question with CallInst::setCalledFunction. But the problems still didn’t have a good solution. SolutionIn my solution, I use a std::map&lt;std::string, int&gt; to store the cloned function’s ID with the same base function, as they are separate functions with their own names. And the IDs are used to generate the new name of the cloned functions. Then I create the new function with the new name and set arguments to it. Next, I use CloneFunctionInto to generate the new function’s implementation, set visibility and linkage, and copy metadata from the base function. The last step is to insert the new function into the module (also the base function’s parent node), and changed the call instruction. CodeHere’s the partial but sufficient key code. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849std::map&lt;std::string, int&gt; calleeCounter;/* * collect the inner bound info for each callee function. */ auto llvmIrCallInstruction = dyn_cast&lt;CallInst&gt;(&amp;llvmIrInstruction); Function * calledFunction = llvmIrCallInstruction-&gt;getCalledFunction(); auto calleeCounterIt = calleeCounter.find(calledFunction-&gt;getName().str()); if (calleeCounterIt != calleeCounter.end()) { calleeCounterIt-&gt;second++; } else { calleeCounter.emplace(calledFunction-&gt;getName().str(), 0); } std::string newFuncName = calledFunction-&gt;getName().str() + '_' + std::to_string(calleeCounterIt-&gt;second); /* * rename the llvmIrCallInstruction to the new function name */ ValueToValueMapTy vMap; auto overloadFunc = Function::Create(calledFunction-&gt;getFunctionType(), calledFunction-&gt;getLinkage(), calledFunction-&gt;getAddressSpace(), newFuncName); auto *newFuncArgIt = overloadFunc-&gt;arg_begin(); for (auto &amp;arg : calledFunction-&gt;args()) { auto argName = arg.getName(); newFuncArgIt-&gt;setName(argName); vMap[&amp;arg] = &amp;(*newFuncArgIt++); } SmallVector&lt;ReturnInst*, 8&gt; Returns; CloneFunctionInto(overloadFunc, calledFunction, vMap, CloneFunctionChangeType::LocalChangesOnly, Returns); // Set the linkage and visibility late as CloneFunctionInto has some // implicit requirements. overloadFunc-&gt;setVisibility(GlobalValue::DefaultVisibility); overloadFunc-&gt;setLinkage(GlobalValue::PrivateLinkage); // Copy metadata SmallVector&lt;std::pair&lt;unsigned, MDNode *&gt;, 1&gt; MDs; calledFunction-&gt;getAllMetadata(MDs); for (auto MDIt : MDs) { if (!overloadFunc-&gt;hasMetadata()) { overloadFunc-&gt;addMetadata(MDIt.first, *MDIt.second); } } Module &amp;funcModule = *calledFunction-&gt;getParent(); funcModule.getFunctionList().insert(calledFunction-&gt;getIterator(), overloadFunc); overloadFunc-&gt;setDSOLocal(true); llvmIrCallInstruction-&gt;setCalledFunction(overloadFunc); PS: I used LLVM-13, and the function CloneFunctionInto may change in different LLVM versions. ConclusionSo this is how to clone functions in LLVM. I will introduce how to eliminate the same (redundant) function after cloning. It will also be fun. Copyright NoticeAnyone is free to use it, and please indicate the reference when using or publishing. Thank you! References[1] https://stackoverflow.com/questions/61189720/llvm-clone-function-pass-to-different-module[2] http://scottcarr.github.io/2016/01/24/my-week-in-llvm.html[3] https://lists.llvm.org/pipermail/llvm-dev/2018-March/122114.html","link":"/2023/01/13/Clone-Function-in-LLVM/"}],"tags":[{"name":"LLVM","slug":"LLVM","link":"/tags/LLVM/"},{"name":"About Me","slug":"About-Me","link":"/tags/About-Me/"}],"categories":[],"pages":[]}